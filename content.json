{"meta":{"title":"LJ","subtitle":"","description":"","author":"LJ","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-03-21T01:48:19.052Z","updated":"2020-03-21T01:48:19.052Z","comments":true,"path":"test.html","permalink":"http://yoursite.com/test.html","excerpt":"","text":"Document button let dom = document.getElementById('dom') dom.onclick = function(){ console.log(this.innerText) } function Person (name){ name: this.name; home: this.home } let LJ = new Person () LJ.name = 'lj'"}],"posts":[{"title":"单页面应用于多页面应用对比","slug":"单页面应用于多页面应用对比","date":"2019-08-10T14:08:25.000Z","updated":"2020-03-21T02:10:36.964Z","comments":true,"path":"2019/08/10/单页面应用于多页面应用对比/","link":"","permalink":"http://yoursite.com/2019/08/10/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E4%BA%8E%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%AF%B9%E6%AF%94/","excerpt":"SPA &amp; MPA","text":"SPA &amp; MPA SPA,SinglePage Web Application,单页面应用 MPA，MultiPage Web Application，多页面应用 看到一个关于单页面应用于多页面应用的对比文字写的挺好的。 自己之前没有想过这个问题，所以记录下来。 之前的页面都是多页面应用，从页面的布局，样式，动效，数据交互都是一点点写出来，比较麻烦。 现在vue的广泛应用，多数都是单页面应用了，如果需要被搜索引擎爬到就需要SSR服务端来渲染。 所以综合来说，并不是一个新技术有绝对的好，只是在不断优化以前的不足。 SPA MPA 组成 一个主页面外壳和多页面片段 多个完成的页面 刷新 页面局部刷新或更新 页面整体刷新 URL模式 www.abc.com/#/index hash 模式 www.abc.com/index.html 数据传递 组件间数据或state数据，容易 依赖url传参，cookie、localStorage等 用户体验 页面片段之间切换流畅，体验较好 页面之间切换加载较慢，体验较差 SEO优化 网页源代码中没有文字，搜索引擎爬不到数据，不利于SEO检索，需要服务端渲染SSR优化。 实现较简单 适用于 追求页面流畅，体验良好的应用 追求高度支持搜索引擎的应用","categories":[],"tags":[{"name":"综合","slug":"综合","permalink":"http://yoursite.com/tags/%E7%BB%BC%E5%90%88/"}]},{"title":"this指向的几点总结","slug":"this指向的几点总结","date":"2018-09-21T01:07:57.000Z","updated":"2020-03-21T01:57:50.349Z","comments":true,"path":"2018/09/21/this指向的几点总结/","link":"","permalink":"http://yoursite.com/2018/09/21/this%E6%8C%87%E5%90%91%E7%9A%84%E5%87%A0%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"this的指向一直是js中的一个比较困惑的点，网上各种总结文章也很多。自己也需要做一些总结，把this指向弄清楚，才不会出现各种undefined的报错哟！","text":"this的指向一直是js中的一个比较困惑的点，网上各种总结文章也很多。自己也需要做一些总结，把this指向弄清楚，才不会出现各种undefined的报错哟！ this是什么？MDN解释：this当前执行代码的环境对象自己的理解：this是函数执行主体，可以理解为谁把函数执行的，谁就是this。 &nbsp; this执行的几种分类 普通函数执行普通函数执行的取决于函数前是否有”点”。 有点，点前面是谁，this就是谁。 没有点，this就是window(严格模式下是undefined)。自执行函数中的this,一般都是window。 12345678910111213141516var a &#x3D; &#39;this is window&#39;function hello() &#123; console.log(this.a)&#125;var obj &#x3D; &#123; a: &#39;this is obj&#39;, hello: function hello() &#123; console.log(this.a) &#125;&#125;hello() &#x2F;&#x2F; this is windowobj.hello() &#x2F;&#x2F; this is obj &nbsp; 元素的事件行为的绑定方法。 给元素的事件行为绑定方法， 事件触发，方法执行，此时方法中的this一般就是当前元素本身。 1234567&lt;button id&#x3D;&#39;dom&#39;&gt;button&lt;&#x2F;button&gt;let dom &#x3D; document.getElementById(&#39;dom&#39;)dom.onclick &#x3D; function()&#123; console.log(this.innerText) &#x2F;&#x2F; button&#125; &nbsp; 构造函数 构造函数new执行，this指向新创建的实例。 12345678function Person (name)&#123; name: this.name; home: this.home&#125;let LJ &#x3D; new Person ()LJ.name &#x3D; &#39;lj&#39; &nbsp; 箭头函数箭头函数没有自己的this。箭头函数中的this是箭头函数创建时当前上下文中的this。如果当前上下文没有this就会向上寻找。所以利用箭头函数的特性可以固定this的指向。 &nbsp; 函数this被bind,call,apply强制修改，以修改后指向为准。 箭头函数是创建时就已经确定了this，又由于箭头函数本身没有this，所以使用call等方法也无法改变其this指向，第一个参数将被忽略。 普通函数则是执行是才明确this。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]}]}